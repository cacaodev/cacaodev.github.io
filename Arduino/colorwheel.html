<html>

<head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <style type='text/css'>
        .disabled {
            background-color: rgba(0, 0, 0, 0.5);
        }

        .enabled {
            background-color: rgba(255, 255, 255, 1);
        }
    </style>
    <script>
        /**
         * degreesToRadians
         *
         * @param {number} degrees
         * @returns {number}  radians
         */
        function degreesToRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        /**
         * generateColorWheel
         *
         * @param {number} [size=400]
         * @param {string} [centerColor='white']
         * @returns {HTMLCanvasElement}
         */
        function generateColorWheel(size, centerColor) {
            if (size === void 0) {
                size = 400;
            }
            if (centerColor === void 0) {
                centerColor = 'white';
            }
            //Generate main canvas to return
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = canvas.height = size;
            //Generate canvas clone to draw increments on
            var canvasClone = document.createElement('canvas');
            canvasClone.width = canvasClone.height = size;
            var canvasCloneCtx = canvasClone.getContext('2d');
            //Initiate variables
            var angle = 0;
            var hexCode = [255, 0, 0];
            var pivotPointer = 0;
            var colorOffsetByDegree = 4.322;
            //For each degree in circle, perform operation
            while (angle++ < 360) {
                //find index immediately before and after our pivot
                var pivotPointerbefore = (pivotPointer + 3 - 1) % 3;
                var pivotPointerAfter = (pivotPointer + 3 + 1) % 3;
                //Modify colors
                if (hexCode[pivotPointer] < 255) {
                    //If main points isn't full, add to main pointer
                    hexCode[pivotPointer] = (hexCode[pivotPointer] + colorOffsetByDegree > 255 ? 255 : hexCode[pivotPointer] + colorOffsetByDegree);
                } else if (hexCode[pivotPointerbefore] > 0) {
                    //If color before main isn't zero, subtract
                    hexCode[pivotPointerbefore] = (hexCode[pivotPointerbefore] > colorOffsetByDegree ? hexCode[pivotPointerbefore] - colorOffsetByDegree : 0);
                } else if (hexCode[pivotPointer] >= 255) {
                    //If main color is full, move pivot
                    hexCode[pivotPointer] = 255;
                    pivotPointer = (pivotPointer + 1) % 3;
                }
                //clear clone
                canvasCloneCtx.clearRect(0, 0, size, size);
                //Generate gradient and set as fillstyle
                var grad = canvasCloneCtx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                grad.addColorStop(0, centerColor);
                grad.addColorStop(1, 'rgb(' + hexCode.map(function(h) {
                    return Math.floor(h);
                }).join(',') + ')');
                canvasCloneCtx.fillStyle = grad;
                //draw full circle with new gradient
                canvasCloneCtx.globalCompositeOperation = 'source-over';
                canvasCloneCtx.beginPath();
                canvasCloneCtx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
                canvasCloneCtx.closePath();
                canvasCloneCtx.fill();
                //Switch to 'Erase mode'
                canvasCloneCtx.globalCompositeOperation = 'destination-out';
                //Carve out the piece of the circle we need for this angle
                canvasCloneCtx.beginPath();
                canvasCloneCtx.arc(size / 2, size / 2, 0, degreesToRadians(angle + 1), degreesToRadians(angle + 1));
                canvasCloneCtx.arc(size / 2, size / 2, size / 2 + 1, degreesToRadians(angle + 1), degreesToRadians(angle + 1));
                canvasCloneCtx.arc(size / 2, size / 2, size / 2 + 1, degreesToRadians(angle + 1), degreesToRadians(angle - 1));
                canvasCloneCtx.arc(size / 2, size / 2, 0, degreesToRadians(angle + 1), degreesToRadians(angle - 1));
                canvasCloneCtx.closePath();
                canvasCloneCtx.fill();
                //Draw carved-put piece on main canvas
                ctx.drawImage(canvasClone, 0, 0);
            }
            //return main canvas
            return canvas;
        }

        // WEBSOCKET
        function WebSocketClient() {
            this.number = 0; // Message number
            this.autoReconnectInterval = 5 * 1000; // ms
        }

        WebSocketClient.prototype.open = function(url) {
            this.url = url;
            this.instance = new WebSocket(this.url);

            this.instance.onopen = () => {
                this.onopen();
            };
            this.instance.onmessage = (data, flags) => {
                this.number++;
                this.onmessage(data, flags, this.number);
            };
            this.instance.onclose = (e) => {
                switch (e.code) {
                    case 1000: // CLOSE_NORMAL
                        console.log('WebSocket: closed');
                        break;
                    default: // Abnormal closure
                        this.reconnect(e);
                        break;
                }
                this.onclose(e);
            };
            this.instance.onerror = (e) => {
                switch (e.code) {
                    case 'ECONNREFUSED':
                        this.reconnect(e);
                        break;
                    default:
                        this.onerror(e);
                        break;
                }
            };
        }

        WebSocketClient.prototype.send = function(data, option) {
            try {
                this.instance.send(data, option);
            } catch (e) {
                console.warn(e);
            }
        }

        WebSocketClient.prototype.reconnect = function(e) {
            console.log(`WebSocketClient: retry in ${this.autoReconnectInterval}ms`, e);
            this.instance.onopen = null;
            this.instance.onclose = null;
            this.instance.onerror = null;
            this.instance.onmessage = null;
            var that = this;
            setTimeout(function() {
                console.log('WebSocketClient: reconnecting...');
                that.open(that.url);
            }, this.autoReconnectInterval);
        }

        WebSocketClient.prototype.onopen = function(e) {
            console.log('WebSocketClient: open', arguments);
        }
        WebSocketClient.prototype.onmessage = function(data, flags, number) {
            console.log('WebSocketClient: message', arguments);
        }
        WebSocketClient.prototype.onerror = function(e) {
            console.log('WebSocketClient: error', arguments);
        }
        WebSocketClient.prototype.onclose = function(e) {
            console.log('WebSocketClient: closed', arguments);
        }

        var wsc = new WebSocketClient();
        wsc.open('wss://' + 'coco.local' + ':81/');

        wsc.onopen = function(e) {
            console.log('WebSocketClient connected:', e);
            setDisabled(false);
        }
        wsc.onclose = function(e) {
            console.log('WebSocketClient closed:', e);
            setDisabled(true);
        }
        wsc.onerror = function(e) {
            console.log('WebSocketClient error:', e);
            setDisabled(true);
        }
        wsc.onmessage = function(message, flags, number) {
            var json = JSON.parse(message.data);
            var type = json.message;
            var data = json.data;

            console.log(`WebSocketClient message #${number}: ${type} ${data}`);

            if (type == 'color') {
                var hexString = '#' + ('000000' + data).substring(data.length, 12);
            }
        }

        function setDisabled(flag) {
            document.getElementById('content').classList.toggle('enabled', !flag);
        }

        function sendColor(modifier, rgbList) {
            var m = modifier + rgbToHex.apply(null, rgbList);
            console.log(m);
            wsc.send(m);
        }

        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? '0' + hex : hex;
        }

        function rgbToHex(r, g, b) {
            return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        var dragging = false;
        //TEST
        //Get color wheel canvas
        function onLoad() {
            var colorWheel = generateColorWheel(800);
            //Add color wheel canvas to document
            document.body.appendChild(colorWheel);
            //Add ouput field
            var p = document.body.appendChild(document.createElement('p'));

            /**
             * colorWheelMouse
             *
             * @param {MouseEvent} evt
             */
            var colorWheelMouse = function(evt) {
                var ctx = colorWheel.getContext('2d');
                var data = ctx.getImageData(evt.offsetX, evt.offsetY, 1, 1);
                p.innerHTML = 'RGB: ' + data.data.slice(0, 3).join(',');
                sendColor('C', data.data.slice(0, 3));
            }

            var colorWheelTouch = function(evt) {
                var ctx = colorWheel.getContext('2d');
                var touch = evt.touches[0];
                var data = ctx.getImageData(touch.clientX, touch.clientY, 1, 1);
                p.innerHTML = 'RGB: ' + data.data.slice(0, 3).join(',');
                sendColor('C', data.data.slice(0, 3));
            }
            //Bind mouse event
            colorWheel.addEventListener('touchmove', function(e) {
                e.preventDefault();
                colorWheelTouch(e);
            }, {
                passive: false
            });

            colorWheel.addEventListener('mousemove', function(e) {
                if (!dragging) return;
                e.preventDefault();
                colorWheelMouse(e);
            }, {
                passive: false
            });

            colorWheel.addEventListener('mousedown', function(e) {
                e.preventDefault();
                dragging = true;
            }, {
                passive: false
            });

            colorWheel.addEventListener('mouseup', function(e) {
                e.preventDefault();
                dragging = false;
            }, {
                passive: false
            });
        }
    </script>
</head>

<body id='content' class='disabled' onload='onLoad();'>

</body>

</html>
